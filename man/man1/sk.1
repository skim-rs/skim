.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH sk 1  "sk 3.4.0" 
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.SH NAME
sk \- Fuzzy Finder in rust!
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.SH SYNOPSIS
\fBsk\fR [\fB\-\-tac\fR] [\fB\-\-min\-query\-length\fR] [\fB\-\-no\-sort\fR] [\fB\-t\fR|\fB\-\-tiebreak\fR] [\fB\-n\fR|\fB\-\-nth\fR] [\fB\-\-with\-nth\fR] [\fB\-d\fR|\fB\-\-delimiter\fR] [\fB\-e\fR|\fB\-\-exact\fR] [\fB\-\-regex\fR] [\fB\-\-algo\fR] [\fB\-\-case\fR] [\fB\-\-typos\fR] [\fB\-\-normalize\fR] [\fB\-\-split\-match\fR] [\fB\-b\fR|\fB\-\-bind\fR] [\fB\-m\fR|\fB\-\-multi\fR] [\fB\-\-no\-multi\fR] [\fB\-\-no\-mouse\fR] [\fB\-c\fR|\fB\-\-cmd\fR] [\fB\-i\fR|\fB\-\-interactive\fR] [\fB\-I \fR] [\fB\-\-color\fR] [\fB\-\-no\-hscroll\fR] [\fB\-\-keep\-right\fR] [\fB\-\-skip\-to\-pattern\fR] [\fB\-\-no\-clear\-if\-empty\fR] [\fB\-\-no\-clear\-start\fR] [\fB\-\-no\-clear\fR] [\fB\-\-show\-cmd\-error\fR] [\fB\-\-cycle\fR] [\fB\-\-disabled\fR] [\fB\-\-layout\fR] [\fB\-\-reverse\fR] [\fB\-\-height\fR] [\fB\-\-no\-height\fR] [\fB\-\-min\-height\fR] [\fB\-\-margin\fR] [\fB\-p\fR|\fB\-\-prompt\fR] [\fB\-\-cmd\-prompt\fR] [\fB\-\-selector\fR] [\fB\-\-multi\-selector\fR] [\fB\-\-ansi\fR] [\fB\-\-tabstop\fR] [\fB\-\-info\fR] [\fB\-\-no\-info\fR] [\fB\-\-inline\-info\fR] [\fB\-\-header\fR] [\fB\-\-header\-lines\fR] [\fB\-\-border\fR] [\fB\-\-wrap\fR] [\fB\-\-history\fR] [\fB\-\-history\-size\fR] [\fB\-\-cmd\-history\fR] [\fB\-\-cmd\-history\-size\fR] [\fB\-\-preview\fR] [\fB\-\-preview\-window\fR] [\fB\-q\fR|\fB\-\-query\fR] [\fB\-\-cmd\-query\fR] [\fB\-\-read0\fR] [\fB\-\-print0\fR] [\fB\-\-print\-query\fR] [\fB\-\-print\-cmd\fR] [\fB\-\-print\-score\fR] [\fB\-\-print\-header\fR] [\fB\-\-print\-current\fR] [\fB\-\-output\-format\fR] [\fB\-\-no\-strip\-ansi\fR] [\fB\-1\fR|\fB\-\-select\-1\fR] [\fB\-0\fR|\fB\-\-exit\-0\fR] [\fB\-\-sync\fR] [\fB\-\-pre\-select\-n\fR] [\fB\-\-pre\-select\-pat\fR] [\fB\-\-pre\-select\-items\fR] [\fB\-\-pre\-select\-file\fR] [\fB\-f\fR|\fB\-\-filter\fR] [\fB\-\-shell\fR] [\fB\-\-shell\-bindings\fR] [\fB\-\-man\fR] [\fB\-\-listen\fR] [\fB\-\-remote\fR] [\fB\-\-tmux\fR] [\fB\-\-log\-file\fR] [\fB\-\-expect\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] 
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.SH OPTIONS
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help (see a summary with \*(Aq\-h\*(Aq)
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.SH SEARCH
.TP
\fB\-\-tac\fR
Show results in reverse order

Often used in combination with \-\-no\-sort
.TP
\fB\-\-min\-query\-length\fR \fI<MIN_QUERY_LENGTH>\fR
Minimum query length to start showing results

Only show results when the query is at least this many characters long
.TP
\fB\-\-no\-sort\fR
Do not sort the results

Often used in combination with \-\-tac Example: history | sk \-\-tac \-\-no\-sort
.TP
\fB\-t\fR, \fB\-\-tiebreak\fR \fI<TIEBREAK>\fR [default: score,begin,end]
Comma\-separated list of sort criteria to apply when the scores are tied.

* **score**: Score of the fuzzy match algorithm

    \- Each criterion could be negated, e.g. (\-index)
    \- Each criterion should appear only once in the list
.br

.br
[\fIpossible values: \fRscore, \-score, begin, \-begin, end, \-end, length, \-length, index, \-index]
.TP
\fB\-n\fR, \fB\-\-nth\fR \fI<NTH>\fR [default: ]
Fields to be matched

A field index expression can be a non\-zero integer or a range expression (`[BEGIN]..[END]`).
`\-\-nth` and `\-\-with\-nth` take a comma\-separated list of field index expressions.

**Examples:**
    1      The 1st field
    2      The 2nd field
    \-1     The last field
    \-2     The 2nd to last field
    3..5   From the 3rd field to the 5th field
    2..    From the 2nd field to the last field
    ..\-3   From the 1st field to the 3rd to the last field
    ..     All the fields
.TP
\fB\-\-with\-nth\fR \fI<WITH_NTH>\fR [default: ]
Fields to be transformed

See nth for the details
.TP
\fB\-d\fR, \fB\-\-delimiter\fR \fI<DELIMITER>\fR [default: [\\t\\n ]+]
Delimiter between fields

In regex format, default to AWK\-style. Escape sequences like \\x00, \\t, \\n are supported.
.TP
\fB\-e\fR, \fB\-\-exact\fR
Run in exact mode
.TP
\fB\-\-regex\fR
Start in regex mode instead of fuzzy\-match
.TP
\fB\-\-algo\fR \fI<ALGORITHM>\fR [default: skim_v2]
Fuzzy matching algorithm

skim_v2 Latest skim algorithm, should be better in almost any case
skim_v1 Legacy skim algorithm
clangd  Used in clangd for keyword completion
fzy     Algorithm from fzy (https://github.com/jhawthorn/fzy)
.br

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
skim_v1: Original skim fuzzy matching algorithm (v1)
.IP \(bu 2
skim_v2: Improved skim fuzzy matching algorithm (v2, default)
.IP \(bu 2
clangd: Clangd fuzzy matching algorithm
.IP \(bu 2
fzy: Fzy matching algorithm (https://github.com/jhawthorn/fzy)
.IP \(bu 2
frizbee: Frizbee matching algorithm, typo resistant Will fallback to SkimV2 if the feature is not enabled
.RE
.TP
\fB\-\-case\fR \fI<CASE>\fR [default: smart]
Case sensitivity

Determines whether or not to ignore case while matching Note: this is not used for the Frizbee matcher, it uses a penalty system to favor case\-sensitivity without enforcing it
.br

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
respect: Case\-sensitive matching
.IP \(bu 2
ignore: Case\-insensitive matching
.IP \(bu 2
smart: Smart case: case\-insensitive unless query contains uppercase
.RE
.TP
\fB\-\-typos\fR [\fI<TYPOS>\fR] [default: disabled]
Enable typo\-tolerant matching

When passed without a value (\-\-typos), uses adaptive formula (pattern_length / 4). When passed with a value (e.g. \-\-typos=2), uses that exact number as the maximum allowed typos. \-\-typos=0 explicitly disables typo tolerance. Applies to both fzy and frizbee matchers.
.TP
\fB\-\-normalize\fR
Normalize unicode characters

When set, normalize accents and other unicode diacritics/others
.TP
\fB\-\-split\-match\fR [\fI<SPLIT_MATCH>...\fR]
Enable split matching and set delimiter

Split matching runs the matcher in splits: foo:bar will match all items matching foo, then :, then bar if the delimiter is present, or match normally if not.
.SH INTERFACE
.TP
\fB\-b\fR, \fB\-\-bind\fR [\fI<BIND>...\fR] [default: ]
Comma separated list of bindings

You can customize key bindings of sk with `\-\-bind` option which takes a  comma\-separated  list  of
key binding expressions. Each key binding expression follows the following format: `<key>:<action>`
See the [KEYBINDS] section for details

**Example**: `sk \-\-bind=ctrl\-j:accept,ctrl\-k:kill\-line`

## Multiple actions can be chained using + separator.

**Example**: `sk \-\-bind \*(Aqctrl\-a:select\-all+accept\*(Aq`

# Special behaviors

With `execute(...)` and `reload(...)` action, you can execute arbitrary commands without leaving sk.
For example, you can turn sk into a simple file browser by binding enter key to less command like follows:

```bash
sk \-\-bind "enter:execute(less {})"
```

Note: if no argument is supplied to reload, the default command is run.

You can use the same placeholder expressions as in \-\-preview.

sk  switches  to  the  alternate screen when executing a command. However, if the command is ex‐
pected to complete quickly, and you are not interested in its output, you might want to use exe‐
cute\-silent instead, which silently executes the command without the  switching.  Note  that  sk
will  not  be  responsive  until the command is complete. For asynchronous execution, start your
command as a background process (i.e. appending &).

With if\-query\-empty and if\-query\-not\-empty action, you could specify the action to  execute  de‐
pends on the query condition. For example:

`sk \-\-bind \*(Aqctrl\-d:if\-query\-empty(abort)+delete\-char\*(Aq`

If  the query is empty, skim will execute abort action, otherwise execute delete\-char action. It
is equal to ‘delete\-char/eof‘.
.TP
\fB\-m\fR, \fB\-\-multi\fR
Enable multiple selection

Uses Tab and S\-Tab by default for selection
.TP
\fB\-\-no\-multi\fR
Disable multiple selection
.TP
\fB\-\-no\-mouse\fR
Disable mouse
.TP
\fB\-c\fR, \fB\-\-cmd\fR \fI<CMD>\fR
Command to invoke dynamically in interactive mode

Will be invoked using sh \-c
.TP
\fB\-i\fR, \fB\-\-interactive\fR
Start skim in interactive mode

In interactive mode, sk will run the command specified by \-\-cmd option and display the results.
.TP
\fB\-I\fR \fI<REPLSTR>\fR [default: {}]
Replace replstr with the selected item in commands
.TP
\fB\-\-color\fR \fI<COLOR>\fR
Set color theme

Format: [BASE][,COLOR:ANSI[:ATTR1:ATTR2:..]]
See [THEME] section for details
.TP
\fB\-\-no\-hscroll\fR
Disable horizontal scroll
.TP
\fB\-\-keep\-right\fR
Keep the right end of the line visible on overflow

Effective only when the query string is empty
.TP
\fB\-\-skip\-to\-pattern\fR \fI<SKIP_TO_PATTERN>\fR
Show the matched pattern at the line start

Line  will  start  with  the  start of the matched pattern. Effective only when the query
string is empty. Was designed to skip showing starts of paths of rg/grep results.

e.g. sk \-i \-c "rg {q} \-\-color=always" \-\-skip\-to\-pattern \*(Aq[^/]*:\*(Aq \-\-ansi
.TP
\fB\-\-no\-clear\-if\-empty\fR
Do not clear previous line if the command returns an empty result

Do not clear previous items if new command returns empty result. This might be useful  to
reduce flickering when typing new commands and the half\-complete commands are not valid.

This is not the default behavior because similar use cases for grep and rg have already been op‐
timized where empty query results actually mean "empty" and previous results should be
cleared.
.TP
\fB\-\-no\-clear\-start\fR
Do not clear items on start
.TP
\fB\-\-no\-clear\fR
Do not clear screen on exit

Do not clear finder interface on exit. If skim was started in full screen mode, it will not switch back to the original  screen, so you\*(Aqll have to manually run tput rmcup to return. This option can be used to avoid flickering of the screen when your application needs to start skim multiple times in order.
.TP
\fB\-\-show\-cmd\-error\fR
Show error message if command fails
.TP
\fB\-\-cycle\fR
Cycle the results by wrapping around when scrolling
.TP
\fB\-\-disabled\fR
Disable matching entirely
.SH LAYOUT
.TP
\fB\-\-layout\fR \fI<LAYOUT>\fR [default: default]
Set layout
.br

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
default: Display from the bottom of the screen
.IP \(bu 2
reverse: Display from the top of the screen
.IP \(bu 2
reverse\-list: Display from the top of the screen, prompt at the bottom
.RE
.TP
\fB\-\-reverse\fR
Shorthand for reverse layout
.TP
\fB\-\-height\fR \fI<HEIGHT>\fR [default: 100%]
Height of skim\*(Aqs window

Can either be a row count or a percentage
.TP
\fB\-\-no\-height\fR
Disable height (force full screen)
.TP
\fB\-\-min\-height\fR \fI<MIN_HEIGHT>\fR [default: 10]
Minimum height of skim\*(Aqs window

Useful when the height is set as a percentage
Ignored when \-\-height is not specified
.TP
\fB\-\-margin\fR \fI<MARGIN>\fR [default: 0]
Screen margin

For each side, can be either a row count or a percentage of the terminal size

Format can be one of:
    \- TRBL
    \- TB,RL
    \- T,RL,B
    \- T,R,B,L
Example: 1,10%
.TP
\fB\-p\fR, \fB\-\-prompt\fR \fI<PROMPT>\fR [default: > ]
Set prompt
.TP
\fB\-\-cmd\-prompt\fR \fI<CMD_PROMPT>\fR [default: c> ]
Set prompt in command mode
.TP
\fB\-\-selector\fR \fI<SELECTOR_ICON>\fR [default: >]
Set selected item icon
.TP
\fB\-\-multi\-selector\fR \fI<MULTI_SELECT_ICON>\fR [default: >]
Set selected item icon
.SH DISPLAY
.TP
\fB\-\-ansi\fR
Parse ANSI color codes in input strings

When using skim as a library, this has no effect and ansi parsing should be enabled by manually injecting a cmd_collector like so:

  use skim::prelude::*;
  
  let _options = SkimOptionsBuilder::default()
    .cmd("ls \-\-color")
    .cmd_collector(Rc::new(RefCell::new(SkimItemReader::new(
      SkimItemReaderOption::default().ansi(true),
      ))) as Rc<RefCell<dyn CommandCollector>>)
    .build()
    .unwrap();

.TP
\fB\-\-tabstop\fR \fI<TABSTOP>\fR [default: 8]
Number of spaces that make up a tab
.TP
\fB\-\-info\fR \fI<INFO>\fR [default: default]
Set matching result count display position

  \- hidden: do not display info
  \- inline: display info in the same row as the input
  \- default: display info in a dedicated row above the input
.br

.br
[\fIpossible values: \fRdefault, inline, hidden]
.TP
\fB\-\-no\-info\fR
Alias for \-\-info=hidden
.TP
\fB\-\-inline\-info\fR
Alias for \-\-info=inline
.TP
\fB\-\-header\fR \fI<HEADER>\fR
Set header, displayed next to the info

The  given  string  will  be printed as the sticky header. The lines are displayed in the given order from top to bottom regardless of \-\-layout option, and  are  not  affected  by \-\-with\-nth. ANSI color codes are processed even when \-\-ansi is not set.
.TP
\fB\-\-header\-lines\fR \fI<HEADER_LINES>\fR [default: 0]
Number of lines of the input treated as header

The  first N lines of the input are treated as the sticky header. When \-\-with\-nth is set, the lines are transformed just like the other lines that follow.
.TP
\fB\-\-border\fR [\fI<BORDER>...\fR]
Draw borders around the UI components
.br

.br
[\fIpossible values: \fRplain, rounded, double, thick, light\-double\-dashed, heavy\-double\-dashed, light\-triple\-dashed, heavy\-triple\-dashed, light\-quadruple\-dashed, heavy\-quadruple\-dashed, quadrant\-inside, quadrant\-outside]
.TP
\fB\-\-wrap\fR
Wrap items in the item list
.TP
\fB\-\-tmux\fR [\fI<TMUX>...\fR]
Run in a tmux popup

Format: `sk \-\-tmux <center|top|bottom|left|right>[,SIZE[%]][,SIZE[%]]`

Depending on the direction, the order and behavior of the sizes varies:

Default: center,50%
.SH HISTORY
.TP
\fB\-\-history\fR \fI<HISTORY_FILE>\fR
History file

Load search history from the specified file and update the file on completion.

When enabled, CTRL\-N and CTRL\-P are automatically remapped to next\-history and previous\-history.
.TP
\fB\-\-history\-size\fR \fI<HISTORY_SIZE>\fR [default: 1000]
Maximum number of query history entries to keep
.TP
\fB\-\-cmd\-history\fR \fI<CMD_HISTORY_FILE>\fR
Command history file

Load command query history from the specified file and update the file on completion.

When enabled, CTRL\-N and CTRL\-P are automatically remapped to next\-history and previous\-history.
.TP
\fB\-\-cmd\-history\-size\fR \fI<CMD_HISTORY_SIZE>\fR [default: 1000]
Maximum number of query history entries to keep
.SH PREVIEW
.TP
\fB\-\-preview\fR \fI<PREVIEW>\fR
Preview command

Execute the given command for the current line and display the result on the preview window. {} in the command
is the placeholder that is replaced to the single\-quoted string of the current line. To transform the replace‐
ment string, specify field index expressions between the braces (See FIELD INDEX EXPRESSION for the details).

**Examples**:

```bash
sk \-\-preview=\*(Aqhead \-$LINES {}\*(Aq
ls \-l | sk \-\-preview="echo user={3} when={\-4..\-2}; cat {\-1}" \-\-header\-lines=1
.TP
\fB\-\-preview\-window\fR \fI<PREVIEW_WINDOW>\fR [default: right:50%]
Preview window layout

Format: [up|down|left|right][:SIZE[%]][:hidden][:[no]wrap][:[no]pty][:+SCROLL[\-OFFSET]]

Determine  the  layout of the preview window. If the argument ends with: hidden, the preview window will be hidden by default until toggle\-preview action is triggered. Long lines are truncated by default. Line wrap can be enabled with :wrap flag. For more interactive commands or previews that draw complex interfaces, the preview can use a PTY with the :pty flag.

Note: the preview will run in a PTY (interactive session) on linux and when wrap is unset

If size is given as 0, preview window will not be visible, but sk will still execute the command in the background.

+SCROLL[\-OFFSET] determines the initial scroll offset of the preview window. SCROLL can be either a  numeric  integer or  a  single\-field index expression that refers to a numeric integer. The optional \-OFFSET part is for adjusting the base offset so that you can see the text above it. It should be given as a numeric integer (\-INTEGER), or as a denom‐ inator form (\-/INTEGER) for specifying a fraction of the preview window height.

Examples:

  # Non\-default scroll window positions and sizes
  sk \-\-preview="head {}" \-\-preview\-window=up:30%
  sk \-\-preview="file {}" \-\-preview\-window=down:2
  
  # Initial scroll offset is set to the line number of each line of
  # git grep output *minus* 5 lines (\-5)
  git grep \-\-line\-number \*(Aq\*(Aq |
    sk \-\-delimiter:  \-\-preview \*(Aqnl {1}\*(Aq \-\-preview\-window +{2}\-5
  
              # Preview with bat, matching line in the middle of the window (\-/2)
              git grep \-\-line\-number \*(Aq\*(Aq |
                sk \-\-delimiter : \\
                    \-\-preview \*(Aqbat \-\-style=numbers \-\-color=always \-\-highlight\-line {2} {1}\*(Aq \\
                    \-\-preview\-window +{2}\-/2

.SH SCRIPTING
.TP
\fB\-q\fR, \fB\-\-query\fR \fI<QUERY>\fR
Initial query
.TP
\fB\-\-cmd\-query\fR \fI<CMD_QUERY>\fR
Initial query in interactive mode
.TP
\fB\-\-read0\fR
Read input delimited by ASCII NUL(\\0) characters
.TP
\fB\-\-print0\fR
Print output delimited by ASCII NUL(\\0) characters
.TP
\fB\-\-print\-query\fR
Print the query as the first line
.TP
\fB\-\-print\-cmd\fR
Print the command as the first line (after print\-query)
.TP
\fB\-\-print\-score\fR
Print the score after each item
.TP
\fB\-\-print\-header\fR
Print the header as the first line (after print\-score)
.TP
\fB\-\-print\-current\fR
Print the current (highlighted) item as the first line (after print\-header)
.TP
\fB\-\-output\-format\fR \fI<OUTPUT_FORMAT>\fR
Set the output format If set, overrides all print_ options Will be expanded the same way as preview or commands
.TP
\fB\-\-no\-strip\-ansi\fR
Print the ANSI codes, making the output exactly match the input even when \-\-ansi is on
.TP
\fB\-1\fR, \fB\-\-select\-1\fR
Do not enter the TUI if the query passed in \-q matches only one item and return it
.TP
\fB\-0\fR, \fB\-\-exit\-0\fR
Do not enter the TUI if the query passed in \-q does not match any item
.TP
\fB\-\-sync\fR
Synchronous search for multi\-staged filtering

Synchronous search for multi\-staged filtering. If specified, skim will launch ncurses finder only after the input stream is complete. e.g. sk \-\-multi | sk \-\-sync
.TP
\fB\-\-pre\-select\-n\fR \fI<PRE_SELECT_N>\fR [default: 0]
Pre\-select the first n items in multi\-selection mode
.TP
\fB\-\-pre\-select\-pat\fR \fI<PRE_SELECT_PAT>\fR [default: ]
Pre\-select the matched items in multi\-selection mode

Check the doc for the detailed syntax: https://docs.rs/regex/1.4.1/regex/
.TP
\fB\-\-pre\-select\-items\fR \fI<PRE_SELECT_ITEMS>\fR [default: ]
Pre\-select the items separated by newline character

Example: \*(Aqitem1\\nitem2\*(Aq
.TP
\fB\-\-pre\-select\-file\fR \fI<PRE_SELECT_FILE>\fR
Pre\-select the items read from this file
.TP
\fB\-f\fR, \fB\-\-filter\fR \fI<FILTER>\fR
Query for filter mode
.TP
\fB\-\-shell\fR \fI<SHELL>\fR
Generate shell completion script

Generate completion script for the specified shell: bash, zsh, fish, etc. The output can be directly sourced or saved to a file for automatic loading. Examples: source <(sk \-\-shell bash) (immediate use) sk \-\-shell bash >> ~/.bash_completion (persistent use)

Supported shells: bash, zsh, fish, powershell, elvish

Note: While PowerShell completions are supported, Windows is not supported for now.
.br

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
bash: Bourne Again SHell
.IP \(bu 2
elvish: Elvish shell
.IP \(bu 2
fish: Friendly Interactive SHell
.IP \(bu 2
nushell: Nushell (nu)
.IP \(bu 2
power\-shell: PowerShell
.IP \(bu 2
zsh: Zsh
.RE
.TP
\fB\-\-shell\-bindings\fR
Generate shell key bindings \- only for bash, zsh and fish

Generate key bindings script after the shell completions See the shell option for more details
.TP
\fB\-\-man\fR
Generate man page and output it to stdout
.TP
\fB\-\-listen\fR [\fI<LISTEN>...\fR]
Run an IPC socket with optional name (defaults to sk)

The socket expects Actions in Ron format (similar to Rust code), see ./src/tui/event.rs for all possible Actions To write to it, see the \-\-remote option or the man page
.TP
\fB\-\-remote\fR [\fI<REMOTE>...\fR]
Send commands to an IPC socket with optional name (defaults to sk)

The commands are read from stdin, one per line, in the same format as the actions in the bind flag. They can also be chained using + as a separator. All other arguments will be ignored
.TP
\fB\-\-log\-file\fR \fI<LOG_FILE>\fR
Pipe log output to a file
.SH DEPRECATED
.TP
\fB\-\-expect\fR \fI<EXPECT>\fR [default: ]
Deprecated, kept for compatibility purposes. See accept() bind instead
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.SH MODES

.SS "Normal mode"

.br
In normal mode, sk reads the input from stdin and displays the results interactively,
.br
and the query is then used to fuzzily filter among the input lines.
.br

.SS "Interactive mode"

.br
Interactive mode is a special mode that allows you to run a command interactively and display
.br
the results. It is enabled by the `\-\-interactive` (or `\-i`) option or by binding the
.br
`toggle\-interactive` action (default: <ctrl\-q>).
.br
The command is specified with the `\-\-cmd` option.
.br

.br
Example: `sk \-\-cmd \*(Aqrg {} \-\-color=always\*(Aq \-\-interactive` will use `rg` to search for the query
.br
in the current directory and display the results interactively.
.br

.SH SEARCH

.br
By default, skim will start in `extended search`, giving some characters will have meaning.
.br
Example: `^test rs$ | sh$` will match items starting with test and ending with rs or sh.
.br

.SS "AND (space)"
A space between terms will act as an \*(Aqand\*(Aq operator and will filter for items matching all terms.
.br

.SS "OR (|)"
A vertical bar between terms will act as an \*(Aqor\*(Aq operator and will filter for items matching one of the terms.
.br

.SS "Exact match (')"

.br
If a term is prefixed by a `\*(Aq`, sk will search for exact occurrences of that term.
.br
Exact search can be enabled by default by the `\-\-exact` command\-line flag. In exact mode, `\*(Aq` will disable exact matching for that term.
.br

.SS "Anchored match (^|$)"
If a term is prefixed by a `^` (resp. suffixed by a `$`), sk will search for matches starting (resp. ending) with that exact term.
.br

.SS "Negation (!)"
If a term is prefixed by `!`, sk will exclude the items that match this term.
.br

.SH KEYBINDS

.br
Keybinds can be set by the `\-\-bind` option, which takes a comma\-separated list of [key]:[action[+action2].
.br
Actions can take arguments, specified either between parentheses `reload(ls)` or after a colon `reload:ls`
.br

.SS "Available keys (aliases in parentheses)"

.br
* ctrl\-[a\-z]
.br
* ctrl\-space
.br
* ctrl\-alt\-[a\-z]
.br
* alt\-[a\-zA\-Z]
.br
* alt\-[0\-9]
.br
* f[1\-12]
.br
* enter
.br
* space
.br
* bspace      (bs)
.br
* alt\-up
.br
* alt\-down
.br
* alt\-left
.br
* alt\-right
.br
* alt\-enter   (alt\-ctrl\-m)
.br
* alt\-space
.br
* alt\-bspace  (alt\-bs)
.br
* alt\-/
.br
* tab
.br
* btab        (shift\-tab)
.br
* esc
.br
* del
.br
* up
.br
* down
.br
* left
.br
* right
.br
* home
.br
* end
.br
* pgup        (page\-up)
.br
* pgdn        (page\-down)
.br
* shift\-up
.br
* shift\-down
.br
* shift\-left
.br
* shift\-right
.br
* alt\-shift\-up
.br
* alt\-shift\-down
.br
* alt\-shift\-left
.br
* alt\-shift\-right
.br
* any single character
.br

.SS "Actions[:default keys][*notes]"

.br
* abort: ctrl\-c  ctrl\-q  esc
.br
* accept(...): enter *the argument will be printed when the binding is triggered*
.br
* append\-and\-select
.br
* backward\-char: ctrl\-b  left
.br
* backward\-delete\-char: ctrl\-h  bspace
.br
* backward\-delete\-char/eof
.br
* backward\-kill\-word: alt\-bs
.br
* backward\-word: alt\-b   shift\-left
.br
* beginning\-of\-line: ctrl\-a  home
.br
* clear\-screen: ctrl\-l
.br
* delete\-char: del
.br
* delete\-char/eof: ctrl\-d
.br
* deselect\-all
.br
* down: ctrl\-j  ctrl\-n  down
.br
* end\-of\-line: ctrl\-e  end
.br
* execute(...): *arg will be a command, see COMMAND EXPANSION for details
.br
* execute\-silent(...): *arg will be a command, see COMMAND EXPANSION for details
.br
* forward\-char: ctrl\-f  right
.br
* forward\-word: alt\-f   shift\-right
.br
* if\-non\-matched
.br
* if\-query\-empty
.br
* if\-query\-not\-empty
.br
* ignore
.br
* kill\-line
.br
* kill\-word: alt\-d
.br
* next\-history: ctrl\-n with `\-\-history` or `\-\-cmd\-history`
.br
* page\-down: pgdn
.br
* page\-up: pgup
.br
* half\-page\-down
.br
* half\-page\-up
.br
* preview\-up: shift\-up
.br
* preview\-down: shift\-down
.br
* preview\-left
.br
* preview\-right
.br
* preview\-page\-down
.br
* preview\-page\-up
.br
* previous\-history: ctrl\-p with `\-\-history` or `\-\-cmd\-history`
.br
* redraw
.br
* refresh\-cmd
.br
* refresh\-preview
.br
* reload(...)
.br
* select\-all
.br
* select\-row
.br
* set\-preview\-cmd(...): *arg will be a expanded expression, see COMMAND EXPANSION for details
.br
* set\-query(...): *arg will be a expanded expression, see COMMAND EXPANSION for details
.br
* toggle
.br
* toggle\-all
.br
* toggle+down: ctrl\-i  tab
.br
* toggle\-in: (\-\-layout=reverse ? toggle+up:  toggle+down)
.br
* toggle\-interactive
.br
* toggle\-out: (\-\-layout=reverse ? toggle+down:  toggle+up)
.br
* toggle\-preview
.br
* toggle\-preview\-wrap
.br
* toggle\-sort
.br
* toggle+up: btab    shift\-tab
.br
* top
.br
* unix\-line\-discard: ctrl\-u
.br
* unix\-word\-rubout: ctrl\-w
.br
* up: ctrl\-k  ctrl\-p  up
.br
* yank: ctrl\-y
.br

.SH "COMMAND EXPANSION"

.br
In the `preview` flag, `execute`, `reload`, `set\-query`... binds, sk will expand placeholders:
.br
* {} (or \-\-replstr if used) will be expanded to the current item.
.br
* {q} (or {cq} for legacy reasons) will be expanded to the current query input.
.br
* {+} will be expanded to either the currently selected items in multi\-select mode, or the current
.br
 item in single\-select.
.br
* {n} will be expanded to the index of the current item.
.br
* {+n} will be expanded to the index(es) of the corresponding {+} item(s).
.br
* {FIELD_INDEX_EXPRESSION} will be expanded to the field index expression run against the current
.br
 item.
.br
* {+FIELD_INDEX_EXPRESSION} will be expanded to the field index expression run against the {+}
.br
 item(s).
.br

.SS "Field index expression"

.br
skim will expand some expressions between {..}.
.br
It will expand to the corresponding fields, separated by the `\-\-delimiter|\-d` option (see there for details).
.br
* `{n}` will be the n\-th field.
.br
* `{n..m}` will be the fields from n to m, inclusive, separated by a space
.br
* `{\-n}` will be the n\-th, starting from the end, \-1 will be the last field etc.
.br

.SH "ENVIRONMENT VARIABLES"

.SS SKIM_DEFAULT_COMMAND
If set, skim will collect items with this command if no input is piped in (defaults to `find .` if not set)
.br

.SS SKIM_DEFAULT_OPTIONS
Will be parsed and used as default options. Example: `\-\-reverse \-\-multi`
.br

.SS SKIM_OPTIONS_FILE

.br
If the variable is set to the path of an existing file, the contents of this file will be parsed and used as default options.
.br
It supports `#` as a comment start, which can be escaped using `##`.
.br
Example:
.br
```
.br
# Preview
.br
\-\-preview \*(Aqecho {}\*(Aq
.br
\-\-preview\-window \*(Aqleft:30%\*(Aq # Preview window
.br
\-\-reverse
.br
\-\-prompt \*(Aq## \*(Aq
.br
```
.br

.SS NO_COLOR
If set to a non\-empty value, will disable coloring
.br

.SH THEME

.br
Available themes:
.br
    * none: base color scheme
.br
    * molokai: molokai 256color
.br
    * light: light 256color
.br
    * 16: dark base16 theme
.br
    * bw: black & white theme
.br
    * dark | default: dark 256color, default value
.br
    * all 4 catppuccin variants:
.br
        * catppuccin\-latte
.br
        * catppuccin\-macchiato
.br
        * catppuccin\-frappe
.br
        * catppuccin\-mocha
.br

.br
Available color names:
.br
    * normal (or empty string): normal text
.br
    * matched (or hl): matched text
.br
    * current (or fg+): current line foreground
.br
    * bg+: current line background (special case, always sets background)
.br
    * current_match (or hl+): matched text in current line
.br
    * query: query text
.br
    * spinner: spinner character
.br
    * info: info text (match count)
.br
    * prompt: prompt text
.br
    * cursor (or pointer): cursor/pointer
.br
    * selected (or marker): selected item marker
.br
    * header: header text
.br
    * border: border lines
.br

.br
Adding `\-fg`, `_fg`, `\-bg`, `_bg`, `\-underline`, `_underline` sets the corresponding part of
.br
the color. For instance, `normal\-fg` (or simply `fg`) will set the foreground normal color.
.br

.br
Color formats:
.br
    * 0\-255: ANSI terminal color
.br
    * #rrggbb: 24\-bit color
.br

.br
Available attrs:
.br
    * x | regular: resets the modifiers, use it before the others
.br
    * b | bold
.br
    * u | underline
.br
    * c | crossed\-out
.br
    * d | dim
.br
    * i | italic
.br
    * r | reverse
.br

.br
Example: `\-\-color \*(Aq16,normal\-fg:0+bold,matched\-fg:#ffffff+u,cursor\-bg:#deadbe\*(Aq` will start with the
.br
 base 16 theme and override it with a bold ANSI color 0 foreground (black), a hex ffffff (full
.br
 white) underlined foreground for matched parts and a #deadbe (pale rose, apparently) cursor background.
.br

.SH LISTEN/REMOTE

.br
skim can be controlled from other processes, using the `\-\-listen` (and optionally `\-\-remote`) flags.
.br

.br
To achieve this, run the server instance using `sk \-\-listen optional_address` (the address defaults to `sk`).
.br
It will then start listening on a named socket for instructions.
.br

.br
To send instructions, you can use `sk \-\-remote optional_address` or any other tool that allows us to interact with such sockets,
.br
such as `socat` on linux: `echo \*(AqToggleIn\*(Aq | socat \-u STDIN ABSTRACT\-CONNECT:optional_address`. Instructions correspond to skim\*(Aqs Actions and need to be sent in Ron format.
.br
When using `sk \-\-remote`, pipe in action chains (see the KEYBINDS section), for instance `echo \*(Aqup+select\-row\*(Aq | sk \-\-remote optional_address`
.br

.SH "EXIT CODES"

.br
* 0: success
.br
* 1: no match
.br
* 130: interrupt (ctrl\-c or esc)
.br
* others: error
.br

.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.SH VERSION
v3.4.0
